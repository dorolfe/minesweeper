<!DOCTYPE html>
<html lang="en-US">
<head>
<!-- Last edit: 2022/11/15 -->
<meta charset="utf-8">
<title>Serious Business</title>

<!-- if(0) { //hiding styles -->

<style id="defaultColors">
body, .bodyBG {
    background-color: #444;
}

body, .bodyFG {
    color: white;
}

small {
    color: #777;
}

small#countdown, .countFG {
    color: #0b3;
}

.buttonsBG,
input[type="submit"],
option,
select {
    background-color: #565;
    border-color: #676;
    color: silver;
}

fieldset legend {
	background-color:  #666F66;
	border: solid 1px gray;
	color: silver;
}

fieldset {
	border: solid 1px gray;
}


table,
tbody,
td,
th,
thead {
    border-color: gray;
    background-color: #666F66;
}

button:hover,
input:hover,
select:hover {
    box-shadow: 0px 0px 10px lime;
}

a,
a:visited {
    color: #252;
}
a:active,
a:hover {
    color: lime;
}

#board td:hover {
	box-shadow: inset 0px 0px 5px 5px limegreen;
}

#board td.flag:hover {
	box-shadow: inset 0px 0px 5px 5px purple;
}

.hint  { background-color: #445258; }
#board td.hint:hover {
	box-shadow: inset 0px 0px 5px 5px silver;

</style>
 
<style id="defaultLayout"> 
/* no color declaration below */
body {
    font-family: "Lato Medium", "Liberation Sans", Arial, Calibri, Tahoma,
    sans-serif;
    font-size: 18px;
}

ul { list-style-type: none; }

button,
input[type="submit"] {
    height: 32px;
    margin: 1px;
}

input[type=range]  { width: 250px; }

button,
input[type="submit"],
option,
select {
    border-radius: 4px;
    margin: 1px;
}


hr {
    clear: both;
	border-width: 0px;
	border-top-width: 0.05em;
	border-top-style: solid; 
}


table,
td,
th,
thead,
tbody {
    text-align: center;
    padding: 3px;
    margin: 2px;
    border-style: solid;
    border-width: 1px;
    border-spacing: 2px;
    line-height: 1.2em;
	font-family: monospace;
}


/* no pref always dark shadow */
.dismiss, .disActive {
    box-shadow: 3px 3px 8px rgba(0,0,0,.35);
}

fieldset { 
	border-radius: 10px;
	padding: 6px;
}

fieldset legend {
    text-align: left;
	text-align: left;
	border-radius: 8px;
	border-style: solid;
	border-width: 2px;
	padding: 5px;
	padding-bottom: 3px;
	padding-top: 3px;
	line-height: 1rem;
}


#remMins {
    break-before: avoid;
    break-after: avoid;
}


/* no pref to dimmer */
#blocker {
  position: absolute;
  right: 0px;
  z-index: 4;
  width: 100vw;
  height: 200vw;
  background: black;
  opacity: 0.7;
  top: 0px;
  display: none;
}

div.board {
    align-content: center;
	align-items: center;
    border: solid 1px gray;
    border-radius: 10px;
	padding: 10px;
	margin-bottom: 6px;
}

table#board { 
	margin-left: auto;
	margin-right: auto;
}

#output {
	border-radius: 10px;
	font-family: monospace; 
	border: solid 1px gray;
	padding: 10px;
	text-align: center;
	height: 26px;
	margin-top: 22px;
	margin-bottom: 22px;
	
}

#board td, td.hint {
	height: 22px;
	width: 25px;
	
}

tr.hint { display: none; }

td.hc { border: 1px solid #89d8fb; }


</style>

<!-- } // end styles -->

</head>
<!-- if(0) { //hiding body -->
<body>
 
        <fieldset id="parameters">
            <legend onclick="toggleUL();" id="L1">Settings</legend> 
            <ul id="settings">
                <li><input type="range" step="1" min="3" max="40" id=w1><label for=w1>Width</label></li>
                <li><input type="range" step="1" min="3" max="30" id=w2><label for=w2>Height</label></li>
                <li><input type="range" step="any" min="1" max="99" id=w3><label for=w3>Saturation</label></li>
                <li><input type="radio" name="difficulty" id=w4 onchange="radio(this)"><label for=w4>Beginner</label> (9 x 9 x 10)</li>
                <li><input type="radio" name="difficulty" id=w5 onchange="radio(this)"><label for=w5>Intermediate</label> (16 x 13 x 40)</li>
                <li><input type="radio" name="difficulty" id=w6 onchange="radio(this)"><label for=w6>Advanced</label> (24 x 15 x 72)</li>
                <li><input type="radio" name="difficulty" id=w7 onchange="radio(this)"><label for=w7>Expert</label> (30 x 16 x 99)</li>
				<li><input type="radio" name="difficulty" id=w8 onchange="radio(this)"><label for=w8>Pro</label> (40 x 20 x 190)</li>
			</ul>
			<button style="margin-left: 0px;" id="b1" onclick="newBoard()">Generate</button>
        </fieldset>


	<div id="output"></div>
	
	
<div class="board">
	<table id="board">
	<th>Future development: mines left, score here, timer here</th>
	</table>
</div>		

<span style="text-align: center; width: 97vw; display: block;">
	<button id="b2" onclick="getMoreHints()">More Clues</button>
</span>
<!-- } //end body -->

<script>
function toggleUL() { 
	const box = getby('settings');
	if (box.style.display == 'none') { box.style.display = 'block'; }
	else {
		box.style.display = 'none';
		getby('L1').innerHTML = 'Click for Settings';
	}
}

function radio(input) {
	const output = getby('output');
	const width = getby('w1');
	const height = getby('w2');
	const satur = getby('w3');
	var area = width.value * height.value;
	
	switch (input.id) { 
		case 'w4': //beginner
			width.value = 9;
			height.value = 9;
			area = width.value * height.value;
			satur.value = (10 * 100) / area
		break;
		
		case 'w5': //intermediate
			width.value = 16;
			height.value = 13;
			area = width.value * height.value;
			satur.value = (40  * 100) / area
		break;
		
		case 'w6': //advanced
			width.value = 24;
			height.value = 15;
			area = width.value * height.value;
			satur.value = (72 * 100) / area
		break;
		
		case 'w7': //expert
			width.value = 30;
			height.value = 16;
			area = width.value * height.value;
			satur.value = (99 * 100) / area
		break;
		
		case 'w8': //pro
			width.value = 40;
			height.value = 20;
			area = width.value * height.value;
			satur.value = (190 * 100) / area
		break;
	}
}


function outputAllMines() { // for debug...
	for (let rows=0; rows<height; rows++) {		
		for (let cols=1; cols<=width; cols++) {
			if (allMines[((rows*width) + cols)-1] == -1) { output.innerHTML += "&nbsp;X"; }
			else { output.innerHTML += "&nbsp;"+allMines[((rows*width) + cols)-1]; }
		}
		output.innerHTML += "<br/>"; 
	}
}


function newBoard() { 
	width = getby('w1').value;
	height = getby('w2').value;
	const satur = getby('w3').value;
	mines = Math.round(width * height * satur / 100); if (mines == 0) { mines = 1; }
	const board = getby('board');	
	
	output.style.display = 'block';
	output.innerHTML = '';
	getby('settings').style.display = 'none';
	getby('L1').innerHTML = 'Click for Settings';
	
	
	
	allMines = []; 
	allMines[width*height -1] = 0;
	allMines.fill(0, 0, width*height);
	
	for (let i=0; i<mines; i++) {
		while (1) { 
			var randIndex = Math.floor(Math.random() * allMines.length);		
		    if (allMines[randIndex] == 0 ) { 
				allMines[randIndex] = -1;
				//console.log()
				break;
			} else { console.log("collision"); }
		}
	}

	//process allMines to reflect mine counts
	for (let i=0; i < allMines.length; i++) {
		if (allMines[i] == 0) {
			let mineCount = 0;
			for (const j of adjacentTo(i)) {
				if (allMines[j] == -1) { mineCount++ ;}
			}
			allMines[i] = mineCount;
		}
	}
	
	console.log(allMines);

	output.innerHTML = "There are  " + mines + " mines in " + allMines.length + " spaces.<br/>";
	//outputAllMines();

	board.innerHTML = '';
	for (let rows=0; rows<height; rows++) {
		let newTR = document.createElement('tr');
		for (let cols=1; cols<=width; cols++) {
			const current = (rows*width) + cols;
			let newTD = document.createElement('td');
			//newTD.innerHTML = '&nbsp;';
			newTD.innerHTML = wave;
			newTD.id = 'c' + current.toString();
			newTD.addEventListener('click', cellClick, false);
			newTR.appendChild(newTD);
		}
		
		if (showHints) {
			const current = rows;
			let newTD = document.createElement('td');
			newTD.innerHTML = '&nbsp;';
			newTD.id = 'hx' + current.toString();
			newTD.className = 'hint';
			newTD.style.display = 'none';
			newTR.appendChild(newTD);
		}
		
		board.appendChild(newTR);
	}
	
	if (showHints) {
		let newTR = document.createElement('tr');
		for (let cols=1; cols<=width; cols++) {
			const current = cols;
			let newTD = document.createElement('td');
			newTD.innerHTML = '&nbsp;';
			newTD.id = 'hy' + current.toString();
			newTD.className = 'hint';
			newTR.appendChild(newTD);
		}
		newTR.className = 'hint';
		board.appendChild(newTR);
	}
}


function cellClick(event) { 
	const isMine = allMines[this.id.split('c')[1]*1-1];
	
	if (isMine == -1) { //You clicked a bomb!!
		document.querySelectorAll('#board td').forEach( (td) => { td.removeEventListener('click', cellClick, false) });
		this.innerHTML = "X";
		this.innerHTML = bomb;
		setTimeout( () => {
			this.innerHTML = explosion; //explosion
		}, 1000);
		output.style.display = 'block';
		output.innerHTML = explosion + "BOOM! You lost!" + explosion;
		setTimeout(revealBoard, 2000);
	}
	else {
		//count all the mines around this and display that number
		mineSweep(this.id);
		
		if (this.innerHTML === '0') { 
			recursiveClear(adjacentTo(id2index(this.id)));
		} else {  markFlags(this.innerHTML, adjacentTo(id2index(this.id))); }
		
		//check win conditions
		let waveCount = 0;
		let flagCount = 0;
		document.querySelectorAll('#board td').forEach((td)=>{
			if (td.innerHTML == String.fromCodePoint(0x1F30A)) { waveCount++; } //unmarked waves
			if (td.innerHTML == String.fromCodePoint(0x1F6A9)) { flagCount++; } //red flags
		});
		
		//status update
		output.innerHTML = "There are  " + (mines-flagCount).toString() + " mines in " + waveCount + " spaces.<br/>";
		
		//win state!
		if ((waveCount+flagCount) == mines) {
			document.querySelectorAll('#board td').forEach( (td) => { td.removeEventListener('click', cellClick, false) });
			output.style.display = 'block';
			output.innerHTML = "WOO! You did it!" + bomb + broom + grats;
			setTimeout(revealBoard, 1);
			setTimeout(flagMines, 100);
		}
		
	}
}


function index2id(i) { i++; return 'c' + i; }
function id2index(i) { return Number(i.split('c')[1]-1); }


function adjacentTo(index) { // returns array of indexes ints, no strings should happen in this function, yet, I have to force types.
	const x = (index % width);
	const y = (~~((index)/width))
	
	if (y === 0) { //top row
		if (x === 0 ) { //top left
			return [index*1+1, index*1 + width*1, index*1 + width*1 + 1]; 
		}
		if (x === width-1 ) { //top right
			return [index-1, index*1 + width*1, index*1 + width*1 - 1]; 
		} //else
		return [index-1, index*1+1, index*1 + width*1 +1, index*1 + width*1, index*1 + width*1 - 1]; 
	} else { 
		if (y === height-1) { //bottom row
			if (x === 0 ) { //bottom left
				return [index*1+1, index - width, index*1 - width*1 + 1]; 
			}
			if (x === width-1 ) { //bottom right
				return [index-1, index - width, index - width - 1]; 
			} //else
			return [index-1, index*1+1, index*1 - width*1 +1, index - width, index - width - 1]; 
		} else {
			if (x === 0) { //left edge
				return [index*1 + width*1 +1, index*1 + width*1, index*1+1, index*1 - width*1 +1, index - width];
			}
			if (x === width-1) { //right edge
				return [index*1 + width*1, index*1 + width*1 - 1, index-1, index - width, index - width - 1];
			} //else main body return all 8 around
			return [index*1 + width*1 +1, index*1 + width*1, index*1 + width*1 - 1,
				index-1, index*1+1, index*1-width*1+1, index - width, index - width - 1]; 
		}
	}
}


function mineSweep(id) {
	var index = id2index(id);
	const cell = getby(id);
	const mineCount = allMines[index];
	
	if (mineCount == 0) { cell.removeEventListener('click', cellClick, false); }
	//cell.removeEventListener('click', cellClick, false);
	cell.style.color = colors[mineCount];
	cell.className = '';
	cell.innerHTML = mineCount.toString();
}


function recursiveClear(neighbors) {
	for (const i of neighbors) {
		if (getby(index2id(i)).innerHTML == String.fromCodePoint(0x1F30A)) {
			mineSweep(index2id(i));
			if (allMines[i] == 0) {
				recursiveClear(adjacentTo(i));
			}
		}

	}
}


function markFlags(count, neighbors) {
	var mineCount = count*1;
	var waveCount = 0;
	var flagCount = 0;
	
	for (const i of neighbors) {
		if (getby(index2id(i)).className == 'flag') { flagCount++; }
		if (getby(index2id(i)).innerHTML == String.fromCodePoint(0x1F30A)) { waveCount++; }
	}
	
	if (waveCount + flagCount == mineCount) { //mark all waves as flags
		for (const i of neighbors) {
			if (getby(index2id(i)).innerHTML == String.fromCodePoint(0x1F30A)) { 
				let cell = getby(index2id(i));
				cell.innerHTML = flag;
				cell.className = 'flag';
				cell.removeEventListener('click', cellClick, false);
			}
		}
	}
	
	if ((mineCount-flagCount == 1) && (waveCount == 2)) { //one mine in two squares
		//output.innerHTML += " (50-50 situation at last click, take a hint?)";
		//console.log('2 waves 1 mine');
		for (const i of neighbors) { //mark these waves as hint candidates
			if (getby(index2id(i)).innerHTML == String.fromCodePoint(0x1F30A)) { getby(index2id(i)).className = 'hc'; }
		}
	
	}
	
	if (flagCount == mineCount) { //sweep all waves, because mines are found, flags are always true so this is safe
		for (const i of neighbors) {
			if (getby(index2id(i)).innerHTML == String.fromCodePoint(0x1F30A)) { 
				let cell = getby(index2id(i));
				mineSweep(cell.id);
			}
		}
	}
}

function revealBoard(id) {
	if (id) {
		const index = id.split('c')[1]*1-1;
		if (allMines[index] == -1) {
			getby(id).innerHTML = bomb;
		} else { 
			mineSweep(id);
		}
	} else {
		console.log("Full board reveal!");
		const TDs = document.querySelectorAll('#board td')
		TDs.forEach( (cell) => {
			if (cell.className !='hint') { revealBoard(cell.id); }
		});
	}
}

function flagMines() {
	for (let i=0; i < allMines.length; i++) {
		if (allMines[i] == -1) { 
			setTimeout( () => {
				getby('c'+(i*1+1)).innerHTML = flag;
			}, Math.floor(350+i*1.5));
		}
	}
}


function getMoreHints() {
	if (getby('hx0').style.display == 'none') {
		const TDs = document.querySelectorAll('td.hint');
		TDs.forEach( (td)=>{
			td.style.display = 'table-cell';
		});
		document.querySelector('tr.hint').style.display = 'table-row';
		getby('b2').innerHTML = 'Get a hint';
		
		//reveal all row and column counts
		for (let x = 0; x<width; x++) {
			let mineCount = 0;
			for (let i = 0;  i < height ; i++) { 
				if (allMines[i*width + x] == -1) { mineCount++; }
			}
			getby('hy' + (x+1).toString()).innerHTML = mineCount.toString();
			getby('hy' + (x+1).toString()).style.color = colors[(mineCount<9)?mineCount:8];
		}

		for (let y = 0; y < height; y++) {
			let mineCount = 0;
			for (let i = 0; i<width ; i++) { 
				if (allMines[y*width + i] == -1) { mineCount++; }
			}
			getby('hx' + y.toString()).innerHTML = mineCount.toString();
			getby('hx' + y.toString()).style.color = colors[(mineCount<9)?mineCount:8];
		}
		//deduct more clues score
	}

	else { 
		//get cells with waves
		let waves = [];
		let zeros = [];
		TDs = document.querySelectorAll('#board td.hc');
		if (TDs.length === 0) { TDs = document.querySelectorAll('#board td'); }
		for (const cell of TDs) { 
			if (cell.innerHTML === String.fromCodePoint(0x1F30A)) {
				if (allMines[id2index(cell.id)] != -1) {
					waves.push(cell.id);
					if (allMines[id2index(cell.id)] === 0) {
						zeros.push(cell.id);
					}
				}
			}
		}
		
		if (zeros.length > 0) { waves = zeros; }
		if (waves.length === 0) { return false; } // no waves to get hints for!

		//pick a wave cell at random
		let theHint = waves[Math.floor(Math.random() * waves.length)];
		
		mineSweep(theHint);
		
		document.querySelectorAll('#board td.hc').forEach((TD)=>{TD.className = '';});
		getby(theHint).className = 'hc';
		setTimeout(()=>{getby(theHint).className='';},550);
	}	
}


function getby(id) { //tired of typing this
	if (id != '') { return document.getElementById(id); }
}


function myMain(cruft) { //this is not in use...
    const time = new Date(Date.now());
    const seconds = time.getSeconds();
    const minutes = time.getMinutes();
    const hour = time.getHours();
    return true;
}


function bloop2(ac, pitch, volume) { //plays a pleasant tone
    let rndPitch = true;
	let beepLength = 1.01;
    var osc = ac.createOscillator();
    osc.onended = function() { return true; }
    
	if (!rndPitch) {
        osc.frequency.value = pitch;
    } else {
        osc.frequency.value = pitch + Math.floor((Math.random() * 90) * 10) + 110;
    }
	
    if (volume == undefined) { volume = userPrefs.toneVol / 100; }	
	
	osc.type = 'square';

    var vol = ac.createGain();
    vol.gain.defaultValue = 0.03 * volume; //percent
    vol.gain.setValueAtTime(0.025 * volume, ac.currentTime);

    var amp = ac.createGain();
    amp.gain.setValueAtTime(0.5, ac.currentTime);

    let variation = Math.floor(Math.random() * Math.floor(15) + 5);
    var lfo = ac.createOscillator();
    lfo.type = 'sine';
    lfo.frequency.value = variation; //hz

    lfo.connect(amp.gain);
    osc.connect(amp);
    amp.connect(vol);
    vol.connect(ac.destination);

    lfo.frequency.value = variation; //hz
    lfo.start(); //connected to amp to osc so only osc has to stop
    osc.start();
    osc.stop(ac.currentTime + beepLength);
} //bloop2

//init ////////////////////////////////////////////////////

var output = document.getElementById('output');
var allMines = [];
var width = 1;
var height = 1;
var mines = 1;
var hints = 0;
var score = 0;
var seconds = 1;
const showHints = true;
const colors = ['blue', 'lightskyblue', 'aquamarine', 'palegreen', 'khaki', 'lightsalmon', 'lightcoral', 'plum', 'orchid'];
const bomb = "&#x1F4A3;";
const explosion = "&#x1F4A5;";
const wave = "&#x1F30A;";
const flag = "&#x1F6A9;";
const grats = "&#x1F389;";
const broom = "&#x1F9f9;";

const AudioContext = window.AudioContext || window.webkitAudioContext;
const ac = new AudioContext();
var pitch = 440;


//setTimeout(loadColorScheme,60,init);

//Event loop //////////////////////////////////////////////
if (0) { // not in use...
    const oneSecond = 1000;
    const oneMinute = oneSecond * 60;

    while (true || queue.waitForMessage()) {
        const IDforTimer = setInterval(myMain, oneSecond * 1, debug('main interval'));
        const IDfornextTask = setInterval(nextTask, oneSecond * 10, debug('slower interval'), false);


        queue.processNextMessage();
    }
}

//end

</script>
</body>
</html>
